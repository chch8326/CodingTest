정렬: 데이터를 특정한 기준에 따라서 순서대로 나열하는 것

1. 선택 정렬(selection sort)
  1) 가장 원시적인 방법으로 매번 가장 작은 것을 선택한다는 의미에서 선택 정렬이라 한다.
  2) 가장 작은 데이터를 선택해 맨 앞의 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복 
  3) 시간 복잡도: O(N^2) -> 다른 정렬 기법들에 비해 시간 복잡도가 높아 문제 풀이에 사용하기는 느린편이다.
  
arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(arr) - 1):
	min_index = i
	
	for j in range(i + 1, len(arr)):
		if arr[i] > arr[j]:
			min_index = j
			
	arr[i], arr[min_index] = arr[min_index], arr[i]
	
print(arr)

2. 삽입 정렬(insertion sort)
  1) 데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 것을 반복
  2) 삽입 정렬은 필요할 때만 위치를 바꾸므로 데이터가 정렬되어 있을 때 훨씬 효율적이며, 선택 정렬에 비해 실행 시간 측면에서 더 효율적이다.
  3) 특정한 데이터를 적절한 위치에 삽입한다는 의미에서 삽입 정렬이라 한다.
  4) 삽입 정렬은 두 번째 데이터부터 시작한다. 왜냐하면 특정한 데이터가 적절한 위치에 들어가기 전에 그 앞까지의 데이터는 이미 정렬되어 있다고 가정하기 때문이다.
  	 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에 그 위치에 삽입된다는 점이 특징이다.
  5) 거의 정렬되어 있는 상태로 입력이 주어지는 문제라면 여타 정렬 알고리즘을 이용하는 것보다 삽입 정렬을 이용하는 것이 정답 확률을 높일 수 있다.
  6) 시간 복잡도: O(N^2)이나 최선의 경우 O(N)의 시간 복잡도를 가진다. 

arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(arr)):
	for j in range(i, 0, -1):
		if arr[j - 1] > arr[j]:
			arr[j - 1], arr[j] = arr[j], arr[j - 1]
		else:
			break
			
print(arr)

3. 퀵 정렬(quick sort)
  1) 기존 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 과정을 반복
  2) 기준(피벗)을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
  3) 퀵 정렬에는 피벗(pivot)이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 기준을 바로 피벗이라고 한다.
  	 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다. 보통 리스트에서 첫 번째 데이터를 피벗으로 정하는 호어 분할 방식을 사용한다.
  4) 피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다.
  5) 퀵 정렬의 시간 복잡도: O(NlogN)
  
arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(arr, start, end):
	# 리스트가 하나 이하의 원소를 담고 있다면 종료
	if start >= end:
		return
		
	pivot = start # 피벗이 첫 번째 데이터인 호어 분할 방식
	left = start
	right = end
	
	while left <= right:
		# 피벗보다 큰 데이터를 찾을 때까지 반복
		while left <= end and arr[pivot] >= arr[left]:
			left += 1
			
		# 피벗보다 작은 데이터를 찾을 때까지 반복
		while right > start and arr[pivot] <= arr[right]:
			right -= 1
			
		# left와 right이 엇갈렸다면 피벗과 right을 바꿈
		if left > right:
			arr[pivot], arr[right] = arr[right], arr[pivot]
		else:
			arr[left], arr[right] = arr[right], arr[left]
	
	# 분할 이후 분할된 왼쪽 부분과 분할된 오른쪽 부분에서 다시 퀵 정렬 수행		
	quick_sort(arr, start, right - 1)
	quick_sort(arr, right + 1, end)
	
quick_sort(arr, 0, len(arr) - 1)
print(arr)

* 짧게 작성한 퀵 정렬 소스코드로 피벗과 데이터를 비교하는 비교 연산 횟수가 증가하므로 시간 면에서는 조금 비효울적이나 더 직관적이고 기억하기가 쉽다.
arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(arr):
	# 리스트가 하나 이하의 원소를 담고 있다면 종료
    if len(arr) <= 1:
        return arr
        
    pivot = arr[0] # 피벗이 첫 번째 데이터인 호어 분할 방식
    tail = arr[1:]
    
    left_side = [x for x in tail if pivot >= x] # 분할된 왼쪽 부분(피벗보다 작아야 함)
    right_side = [x for x in tail if pivot < x] # 분할된 오른쪽 부분(피벗보다 커야함)
    
    # 분할 이후 분할된 왼쪽 부분과 분할된 오른쪽 부분에서 다시 정렬을 수행하고, 전체 리스트를 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
    
print(quick_sort(arr))

4. 계수 정렬(count sort)
  1) 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있고, 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 사용할 수 없다.
  	 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다. 
  2) 계수 정렬이 1번과 같은 특징을 가지는 이유는 모든 범위를 담을 수 있는 크기의 리스트를 선언해야하기 때문이다.
  3) 계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘처럼 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 비교 기반의 정렬 알고리즘이 아니다.
  	 계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다. 결과적으로 리스트에는 각 데이터가 몇 번 등장했는지 그 횟수가 기록된다.
  4) 시간 복잡도: 모든 데이터가 양의 정수인 상황에서 데이터의 개수를 N, 데이터 중 최대값의 크기를 K라고 할 때 O(N + K)이다.	 
  	 -> 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라 추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 
  	    데이터 중 최대값의 크기만큼 반복을 수행해야 한다. 따라서 데이터의 범위만 한정되어 있으면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다.

arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 모든 범위를 포함하는 리스트를 선언하고, 값을 0으로 초기화
count = [0] * (max(arr) + 1) # 0도 포함이 되야하므로 1을 더해줘야 함

# 각 데이터에 해당하는 인덱스의 값 증가
for i in range(len(arr)):
	count[arr[i]] += 1

# 리스트에 기록된 정렬 정보 확인
for i in range(len(count)):
	for j in range(count[i]):
		print(i, end = ' ')
		
python의 정렬 라이브러리
1. sorted()
  1) 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는대 병합 정렬은 퀵 정렬보다 느리지만 최악의 경우에도 시간 복잡도가 O(NlogN)을 보장한다.
  2) 리스트, 딕셔너리, 집합 자료형 등을 입력받아서 정렬된 결과를 출력한다. 집합, 딕셔너리 자료형을 입력 받아도 반환되는 결과는 리스트이다.
  
arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

result = sorted(arr)
print(result)

2. sort(): 리스트 변수가 하나 있늘 때 내부 원소를 바로 정렬할 수 있다. 이를 이용하면 별도의 정렬된 리스트가 반환되지 않고 내부 원소가 바료 정렬된다.

arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
arr.sort()
print(arr)